协议都走JSON格式，好处主要是提高可读性，还有就是代码解析容易。

Json安装：
sudo apt-get install libjsoncpp-dev

安装完后要迅速掌握怎么使用Json，看这个例子跑一下就明白了（主要看例子4，怎么序列化Json变成字符串）
https://www.cnblogs.com/liaocheng/p/4243731.html



主Json格式定义(车发到调度，调度发到车都是这个格式)：
["Dev_Type"] = "AGV"/"ELE"/"WMS"/"MES"/"UI"/"PAD"/"Core"  注释：这个字段定义连接的设备类型，数据类型为字符串；AGV 小车；ELE 电梯；WMS 库位管理系统；MES 生产管理系统；UI 看板；PAD 手持式监控呼叫终端；Core调度内核
["Dev_ID"] = 1/2.....   注释：这个字段定义该类的设备的唯一的标识序号，数据类型为整型（如果是发送设备是调度，这个值永远是1）；
["Dev_Data"] 注释：这个字段作为一个嵌套的子Json格式，根据发送的不同设备具有不同的定义。



["Dev_Data"]子Json格式定义（调度发送到AGV的命令）,组成结构如下：
    ["TimeStamp_sec"] = 1314851429  注释：这个字段定义该指令的发送时间,数据类型为timeval的tv_sec部分,实质为long long int型（一个特定的时间:指示从1970-01-01 00:00:00 UTC为起点，到当前所经历的秒数）
    ["TimeStamp_usec"]= 12345      注释：这个字段定义该指令的发送时间,数据类型为timeval的tv_usec部分,实质为int型
    ["Comm_ID"] = 1/2/3......    注释：这个字段定义该调度发送该命令的编号，数据类型为整型；
    ["AGV_ID"]  = 1/2/3......    注释：这个字段定义该调度发送到的目标AGV编号，数据类型为整型；
    ["Time"] = 0/1/2/3......   　　注释：这个字段定义这条指令已经发送的次数，数据类型为整型；
    ["Comm_Type"] = 命令指令："MOVE"/"PROC"　　（对应AGV的握手信息为"FB_MOVE"/"FB_PROC"）
　　　　　　　　　　          AGV执行结果调度收到后的握手： "FB_RT_MOVE"/"FB_RT_PROC"  （对应AGV的执行结果"RT_MOVE"/"RT_PROC"的握手）
                    注释：这个字段定义该命令的类型，数据类型字符串。发送的可能是两类指令，命令(MOVE或者PROC命令)或者是握手回馈（"FB_RT_MOVE"/"FB_RT_PROC"）。
　　　　　　　　　　　　　其中只有"MOVE"/"PROC"需要进一步展开定义；　
　　　　　　　　　　　　　　　　　　　　　　　　"FB_RT_MOVE"/"FB_RT_PROC"只是告诉AGV,调度系统已经收到了由AGV发送的命令执行结束状态（特别强调："FB_RT_MOVE"/"FB_RT_PROC"的["Comm_ID"]仍然是和从AGV收到结果该字段一样的值）
                    
　　命令PROC的嵌套Json结构定义：
    ["PROC"]       注释：这个字段定义该AGV设备的当前的执行的动作；其本身也是也一个嵌套的子Json结构，其结构如下：
        ["Proc_Name"] = "CAMERAGRAIN"   注释：这个字段定义该AGV设备的当前需要执行的动作,数据类型是字符串；下面是动作的举例
                  以下列举国轩项目用到的的指令：
                  \param  TURNROUND  　 90，　　注释：车头左转９０度,右转为负角度
　　　　　　　　　　　　　　　　　　\param  MAGNETICTRACK_LOCATION  1.08/-0.52,    　注释：磁轨定位命令　运动到距离原点开始处正向1.08米的位置/ 运动到距离原点开始处反向0.52米的位置
                  \param  ROLLER_MOTOR   1   LOAD/UNLOAD,　　　　　　　　　注释：电机旋转　　１号机　正/反转　
                  \param  LOCATINGPIN　　　　1   LOAD/UNLOAD,         注释：定位销动作　１号销　出/回　　　　　　　
                  \param  CHANGE_NAV_MODE  MAGNET/SLAM/QRCODE/REFLECT  注释：导航方式切换指令　　 MAGNET　磁轨　　　/SLAM　自然导航　　　/QRCODE　二维码　　　/REFLECT　反光板
                  \param  ODOMETRY_GOALONG 　0.8,　　　　　　注释：利用里程计导航向前行走0.8米,负值向后行走
                  \param  CHARGE_START    1,          注释：充电开始，充电桩是１号充电桩（小车开始和１号充电桩交互）
                  \param  CHARGE_OVER     3,          注释：充电结束，充电桩是３号充电桩（小车开始和３号充电桩交互）
　　　　　　　　　　　　　　　　　　\param  CANCEL_CURCMD               注释：取消任务命令
        ["Proc_Para_1"] =   注释：某些动作执行需要跟上一些参数（不需要后接参数的动作该部分参数可以为空），这个字段就是定义总做参数，根据具体的动作会有不同，数据类型维浮点型。
        ["Proc_Para_2"] =   同上
        ["Proc_Para_3"] =   同上
        ["Proc_Para_4"] =   同上
        ["Proc_Para_5"] =   同上
        ["Proc_Para_6"] =   同上



　　命令MOVE的嵌套Json结构定义：
    ["MOVE"] 子Json格式,定义下面要走的点,这个子Json格式展开后如下：
        ["CombPathID"] = 0/1/2..   注释：这个字段定义当前发送的CombPath的ID号码，数据类型为整型；
　　　　　　　 ["LastCombPathID"] = 1/2..   注释：这个字段定义最后一组CombPath的ID号码，数据类型为整型；
        ["Points_Num"] = 10  注释：这个字段定义下面要走的点的数量，数据类型为整型；
　　　　　　　　["Posture"] = 0  注释：这个字段定义这个行走命令的姿态，数据类型为整型，０表示正向行驶，１８０表示倒行；
        ["AcrossID"] = -1/0/1/2/...  注释：这个字段定义这段路经过的岔路口的ID（在岔路口可以进行姿态调整，比如掉头）,数据类型为整形；　-1的时候表示这个路径中不包含岔路口，非-1的值代表岔路口的ＩＤ；
        ["Points_Array"] 注释：这个字段定义下面要走的点的数组，类型是Json数组；数组中的每个item都是一个子Json，意义是一个点，定义如下：
                         ID 点的编号，整形  X Y 坐标信息，浮点型  a 角度信息，浮点型（0表示无效，真实的零度角用0.01这样表示）
                         ["ID"]= 1 ..............["ID"]= 10 
                         ["X"] = 106.32 .........["X"] = 826.32
                         ["Y"] = -81.56 .........["Y"] = -70.56
                         ["a"] = 0.0 ............["a"] = 85.6




["Dev_Data"]子Json格式定义（AGV回馈到调度）：
    ["Time_stamp"] = 1314851429  注释：这个字段定义该指令的发送时间,数据类型为timeval的tv_sec部分,实质为long int型（一个特定的时间:指示从1970-01-01 00:00:00 UTC为起点，到当前所经历的秒数）
    ["Comm_ID"] = 1/2/3......  注释：这个字段定义该调度发送命令的编号，数据类型为整型；这个作为调度命令反馈（握手或是执行结束），平时可以不填写；
    ["Map_ID"]  = 1/2/3......  注释：这个字段定义该车当前所处的场景地图编号，数据类型为整型；
    ["X"] = 100.56    注释：这个字段定义该AGV设备的当前的X世界坐标，数据类型为浮点型，单位米；
    ["Y"] = -28.68    注释：这个字段定义该AGV设备的当前的Y世界坐标，数据类型为浮点型，单位米；
    ["a"] = -56.83    注释：这个字段定义该AGV设备的当前的世界坐标中的姿态角，数据类型为浮点型，单位度；
    ["Cell_Quan"] = 0.98  注释：这个字段定义该AGV设备的当前的电量，数据类型为浮点型；
    ["ERROR"] = 1     注释：这个字段定义该AGV设备的当前的状态，数据类型为整型；比如缺电状态，机械故障，电气故障，定位丢失...等等这些小车自诊断能得到的结果，数据类型为long long int(64位整型),定义如下：
			　　数据一共有64位，所以可以表达64种错误的组合（此处只定义了几种异常，剩余可以自己补充）

　　　　　　　　　　　　高字节－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－低字节
　　　　　　　　　　　　字节８　　字节７　　　字节６　　　字节５　　字节４　　字节３　　字节２　　字节１
　　　　　　　　　　　　　　　　　　　　　　00000000  00000000  00000000  00000000  00000000  00000000  00000000  00000000

		      00000000  00000000  00000000  00000000  00000000  00000000  00000000  00000001 急停按下
		　　　　　　00000000  00000000  00000000  00000000  00000000  00000000  00000000  00000010 驱动器故障
		　　　　　　00000000  00000000  00000000  00000000  00000000  00000000  00000000  00000100 滚轮电机2故障
		　　　　　　00000000  00000000  00000000  00000000  00000000  00000000  00000000  00001000 滚轮电机1故障
		　　　　　　00000000  00000000  00000000  00000000  00000000  00000000  00000000  00010000 前磁轨传感器故障
		　　　　　　00000000  00000000  00000000  00000000  00000000  00000000  00000000  00100000 后磁轨传感器故障




    ["Data_Type"] =   "NORMAL" 　　 注释：表示这是一个普通的车的状态信息，以下的信息无需解析
                      "FB_MOVE"/"FB_PROC" 　　　 注释：定义AGV握手的信息，对应调度发送的"MOVE"/"PROC"指令的握手，　　"FB_MOVE"移动命令握手　　　"FB_PROC"动作命令握手
　　　　　　　　　　　　　　　　　　　　　　"RT_MOVE"/"RT_PROC"     注释：定义AGV命令执行结果，　"RT_MOVE"移动命令执行结果　"RT_PROC"动作命令执行结果 
　　　　　　注意："RT_MOVE"/"FB_MOVE"  MOVE指令不管是握手还是执行结果，下面都不用在展开了。
　　　　　　　　　　　　　　　　　"FB_MOVE"/"FB_PROC"　　"RT_MOVE"/"RT_PROC"　　发送的时候["Comm_ID"]字段必须是调度发送命令的时候的命令编号。

    ["FB_PROC"] 注释：嵌套的Json结构，用来回馈动作命令
        ["Proc_Name"] = "PT_CAMERAGRAIN"   注释：这个字段定义该AGV设备的当前需要执行的动作（如果没有动作就是空）；下面是动作的举例（后续会再补充）　　　　　　

　　　　["RT_PROC"] 注释：嵌套的Json结构，用来回馈动作命令
        ["Proc_Name"] = "PT_CAMERAGRAIN"   注释：这个字段定义该AGV设备的当前需要执行的动作（如果没有动作就是空）；下面是动作的举例（后续会再补充）　　　　　　
        ["Proc_Result"] = 1.0   注释：这个字段定义该AGV设备的当前的执行动作的结果，浮点型数据；大部分动作执行后没有结果，但是一些动作会有比如"PT_CAMERAGRAIN  2",相机拍照识别2号物体是否存在；
    
备注：
1 小车到调度的回馈（所有回馈字符串的结束符都是“0x0d0x0a”，也就是说Json串行化后的字符串必须再添加这两个结束符），这个需要按照一定的频率发送，一秒2~5次。我调度系统会把这个作为心跳包来判定网络的中断。
2 调度系统发送到小车的命令时间上是随机的，["Comm_ID"]这个字段是用来做一个信号发送的握手，当小车接到新的命令之后，不需要当即回馈，仍按照定好的心跳在下一（或者两次）次反馈时在["Comm_ID"]字段添加相同的键值。平时小车没有接收到调度命令["Comm_ID"]的字段值为空。




